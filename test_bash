#! /bin/bash                        # указание используемого интерпритатора


a=375
hello=$a                            # можно и так ${a}
echo $hello                         # '$' - это ссылка на переменную

textfile=`cat test_bash`            #  `` - подстановка команд, можно и такую: $()
echo $textfile                      # вывод команды в коммандную строку

rm `cat filename`                   # filename - содержит списолк файлов, rm - удаляет эти файлы

hello="A B           C   D"         # "" - экранирует некоторый служебные символы, 
hello_s=$hello                      # '' - экранирует все служебные символы
echo $hello_s                       # \X повзоляет символ X

echo $?                             # просмотр кода завершения

lskdf
echo $?

exit 113                            # прямое указание с каким кодом завершения завершить процесс

com1=$(date)
echo "$com1 RLS WORK"

com2=$(cat<sample.txt)
echo $com2

echo -n "Введите 'var1' и 'var2': " # ключ -n подавляет вывод переноса строки
read var1 var2                      # ввести переменные
echo "var1=$var1 var2=$var2"        

com3=$(cat <<end)                    # ввод до тех пор пока не ввведем end
echo $com3

# { ... } - вложенный блок

# {
# ...
# ...
# } > test # запись результата в блоке в файл test

# $1, ${10},$*, $#, $_ - аргументы предыдущей команды, для первых 10 частей, от 10, все аргкменты, их количество, последний предыдущей

# let, expr, (( ... )) - позволяет делать арифметические поерации над числами

# let a = a + 5
# a =$(($t + 1))

test Stroka1 = Stroka1 # test - возвращает только код возврата, можно и так [ Stroka1 = Stroka1 ]

# [ ... \> ... ] чтобы не экранировать, чтобы было больше, а не перенаправление [[ ... ]]

# if ...;   - возвратит $? (код возврата)
# then
# ...
# else
# ...
# fi

# сравнение чисел в ((...)) с помощью стандартных операций, а в [ ... ] используются вместо них мнемоники

# примеры
a=4 # !!! строки
b=3
if (("$a" > "$b"))
if ["$a" -ne "$b"]

# сравнение строк
if ["$a" != "$b"] && ["$c" != "$d"] # логика последовательно прогоняется (если выполнится первый, то выполнится второй)

# циклы
# for arg in [список]
# do 
#
# done

# пример
# for i in $(seq 1 20) # можно и упрощение использовать {1...20}
# do
# echo $i 
# done

# можно и в одну строчку do написать
# for arg in [список] ; do

for ((a=1;1<= LIMIT;a++))
do
  echo -n "$a"
done

# цикл с условием while

var0 = 0
LIMIT = 10

while [ "$var0" -it "$LIMIT"]
do
...
done

# break - прерывает цикл
# continue - возвращает в начало (пропускает)

# case (in) / esac # вместо много ифов
case "$a" in
"a") echo a;;
"b") echo b;;
esac

# select - позволяет сделать инструкции при создании меню
select переменная in [список]

PS3 = 'Введите ваш факультет'
select fak in "ИУ1","ФН1","РК"
do
echo ...
...
break
done                      

# Системы счисления

без ничего - десятичное
нолик в начале - восьмиричное 
0x в начале - шестнадцеричное
либо для всех так 16#11
или так 16#12

let "b32 = 32#77"
let "a = 0x32"
...

declare -r var1     # -r это readonly теперь она только на чтение
declare -i var1     # integer для предопеределния, но не рабботает
declare -a var1      # array - обьявление массивом, либо сразу его создаём
declare -x var3     # разрешаем потомкам видеть переменную
...

# Работа со строками
${a} - строка
${#a} - длина строки

# чтобы узнать длину в подстроке
expr match "$строка" '$подстрока'          # или такая запись expr "$строка":'$подстрока'

# Извлечение подстроки (срезы)
echo ${string1:7} # вырезаем с 1 по 7 значение
...

# Масссивы
echo ${a[1]} - элемент массива



